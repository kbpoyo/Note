## 8086架构(16bit)

以下寄存器都是16bit位宽

![](https://pic4.zhimg.com/v2-c70bc72bb0f7474457643413a5f7996b_b.jpg)

## x86架构

### 通用寄存器(32bit)

通用寄存器是程序执行代码最最常用，也最最基础的寄存器，程序执行过程中，绝大部分时间都是在操作这些寄存器来实现指令功能。

- **_eax：_** 通常用来执行加法，函数调用的返回值一般也放在这里面
- **_ebx：_** 数据存取
- **_ecx：_** 通常用作计数器，比如[for循环](https://www.zhihu.com/search?q=for%E5%BE%AA%E7%8E%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22502718676%22%7D)
- **_edx：_** 暂不清楚
- **_esp：_栈顶指针，指向栈的顶部**
- **_ebp：_栈底指针，指向栈的底部，通常用`ebp+偏移量`的形式来定位函数存放在栈中的局部变量**
- **_edi：_** 字符串操作时，用于存放数据源的地址
- **_esi：_** 字符串操作时，用于存放目的地址的，和_edi_两个经常搭配一起使用，执行字符串的复制等操作

### 标志寄存器(32bit)

标志寄存器 **_eflags_**，记录了CPU执行指令过程中的一系列状态，这些标志大都由CPU自动设置和修改。

![](https://pic4.zhimg.com/v2-90c2e7f9796673ea63b1250ac3aa743f_b.jpg)

- **_CF：_** 进位标志
- **_PF ：_** 奇偶标志
- **_ZF ：_** 零标志
- **_SF ：_** 符号标志
- **_OF ：_** 补码溢出标志
- **_TF：_** 跟踪标志
- **_IF ：_** 中断标志

### 指令寄存器(32bit)

**_eip_** 寄存器是CPU中最最重要的寄存器了，它指向了下一条要执行的指令所存放的地址，CPU的工作其实就是不断取出它指向的指令，然后执行这条指令，同时指令寄存器继续指向下面一条指令，如此不断重复，这就是CPU工作的基本日常。

### 段寄存器(16bit)

- **_cs：_** 代码段
- **_ds：_** 数据段
- **_ss_** **_：_** 栈段
- **_es：_** 扩展段
- **_fs_**:**_：_** 数据段
- **_gs：_** 数据段

段寄存器里面存储的内容与CPU当前工作的内存寻址模式紧密相关，详细可查阅：

[CPU工作模式：执行程序的三种模式8 赞同 · 0 评论文章![](https://picx.zhimg.com/v2-f621f848f82047494635b32ec2c1eb2b_r.jpg?source=172ae18b)](https://zhuanlan.zhihu.com/p/502776497)

  
段寄存器通过**_Index_**查找**_GDT表_**找到段所在的线性地址，进而开展后续工作。

![](https://pic1.zhimg.com/v2-3a97741c711b66ca18ecfae2f9810840_b.jpg)

段寄存器结构

### 控制寄存器(32bit)

控制寄存器记录cpu运行过程中自身的一些关键信息，包括cr0~cr4寄存器。

![](https://pic3.zhimg.com/v2-97470bf59fc9f15a3bb0c4926bca060a_b.jpg)

cr0寄存器

- **_PG：_** 开启[分页模式](https://www.zhihu.com/search?q=%E5%88%86%E9%A1%B5%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22502718676%22%7D)
- **_CD：_** 控制**Cache**高速缓存功能，CD=1关闭该功能
- **_NW：_** 控制使用通写还是回写，用于维护内存数据一致性，NW=1关闭该功能，数据一致性即通过**MESI协议**
- **_AM：_** 控制启用内存对齐自动检查
- **_WP：_** 控制开启内存写保护，WP=0开启写保护，对只读页面尝试写入将触发异常，这一机制常常被用来实现**写时复制**功能
- **_PE：_** 如果PE=1，则保护模式启动，如果PE=0，则在实模式下运行

```text
mov eax, cr0
;开启 保护模式和分页模式
bts eax, 0    ;CR0.PE =1
bts eax, 31   ;CR0.PG = 1
;开启 CACHE 
btr eax, 29   ;CR0.NW=0
btr eax, 30   ;CR0.CD=0
mov cr0, eax 
```

-

![](https://pic3.zhimg.com/v2-42dfe95feced0146ca2d7145c27c99f2_b.jpg)

cr1寄存器

**_cr1_** 寄存器暂且保留未使用

-

![](https://pic2.zhimg.com/v2-46c5f9fc643e0fa43a9d6f7c96708485_b.jpg)

cr2寄存器

**_cr2_** 寄存器页错误出现时保存导致出错的地址，比如缺页异常。

-

![](https://pic2.zhimg.com/v2-50e6c56a13697742651ca65af51b503d_b.jpg)

cr3寄存器

**_cr3_** 寄存器和**MMU**密切相关，保存了当前进程所使用的虚拟地址空间的**页目录地址**，可以说是整个虚拟地址翻译中的顶级指挥棒，**在进程空间切换的时候，CR3也将同步切换**。

**_cr3_** 寄存器的高20位用于保存**页目录地址**，0-11位记录标记位，所以**页目录地址**必须是4KB的整数倍。

```c-objdump
mov eax, PAGE_TLB_BADR;页表物理地址
mov cr3, eax
```

-

![](https://pic4.zhimg.com/v2-34cad0c93a9debdc7109d695dc9399d3_b.jpg)

cr4寄存器

- **_PAE：_** PAE = 1，使分页产生超过32位的物理地址，当清除时，限制物理地址为32位。**在进入IA-32e模式（长模式）之前必须设置PAE.**
- **_PSE_：** PSE = 1, 使分页的页大小为4mb，0则使分页的页大小为4kb。

```text
;长模式下，开始分页保护
mov eax, cr4
bts eax, 5   ;CR4.PAE = 1
mov cr4, eax ;开启 PAE
mov eax, PAGE_TLB_BADR ;物理页地址
mov cr3, eax
```

### 描述符寄存器

- **_GDTR(48bit)_**

全局描述符表寄存器，CPU现在使用的是段+分页结合的内存管理方式，那系统总共有那些分段呢？这就存储在一个叫全局描述符表（**GDT**）的表格中，并用 **_gdtr_** 寄存器指向这个表。这个表中的每一项都描述了一个内存段的信息。

- **_LDTR(16bit)_**

局部描述符表寄存器，这个寄存器和上面的 **_gdtr_** 一样，同样指向的是一个段描述符表（ **LDT** ）。不同的是，**GDT**是全局唯一，**LDT**是局部使用的，可以创建多个，随着任务段切换而切换（下文介绍任务寄存器会提到）。

![](https://pic3.zhimg.com/v2-66df2ffcd904087e7e87b6ffe02c8372_b.jpg)

gdtr、ldtr与gdt、ldt关系

**GDT**和**LDT**中的表项，就是段描述符，一个表项占据8个字节，里面存储了一个内存分段的诸多信息：基地址、大小、权限、类型等信息。其结构如下：

① 32位段基址

② 20位段界限，即段长，粒度由G位控制

③ 粒度位G位：

当G = 0时，段长以字节为单位，则最大段长为2^20B = 1MB

当G = 1时，段长以页（4KB）为单位，则最大段长为2^20 \* 4KB = 4GB

![](https://pic1.zhimg.com/v2-fea89f4707016cb82e059564cb308c84_b.jpg)

段描述符结构

**IDT**中的表项称为**Gate**，中文意思为**门**，因为这是应用程序进入内核的主要入口，表中存储的不全是[中断描述符](https://www.zhihu.com/search?q=%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22502718676%22%7D)，**IDT**中的表项存在三种类型，存储了处理这个中断/异常/任务时该去哪里处理的地址，对应三种类型的门：

- **任务门**
- **陷阱门**
- **中断门**

![](https://pic1.zhimg.com/v2-8d36cace8299d4f8499eb6af2ba54f1c_b.jpg)

idt表项结构

- **_IDTR(48bit)_**

中断描述符表寄存器，指向了**中断描述符表IDT**，这个表的每一项都是一个中断处理描述符，当CPU执行过程中发生了硬中断、异常、软中断时，将自动从这个表中定位对应的表项，里面记录了发生中断、异常时该去哪里执行处理函数。

![](https://pic3.zhimg.com/v2-9c032dd138a561f145a173bb68d888c2_b.jpg)

idtr寄存器与idt关系

### 任务寄存器(16bit)

- **_TR：_** 指向当前运行的任务

![](https://pic2.zhimg.com/v2-26ee4b7be502638dd3b890a9499a916d_b.jpg)

tr寄存器同tss关系

- 定义了描述任务的数据结构**TSS（任务状态段）**，里面存储了一个任务的上下文（一系列寄存器的值），下图是一个32位CPU的TSS结构图：

![](https://pic2.zhimg.com/v2-3f1221e3278a9c61bb39a27de5315461_b.jpg)

TSS段结构

> x86CPU的构想是每一个任务对应一个TSS，然后由TR寄存器指向当前的任务，执行任务切换时，修改TR寄存器的指向即可，这是硬件层面的多任务切换机制。  
> 这个构想其实还是很不错的，然而现实却打了脸，包括Linux和Windows在内的主流操作系统都没有使用这个机制来进行线程切换，而是自己使用软件来实现多线程切换。  
> 所以，绝大多数情况下，TR寄存器都是指向固定的，即便线程切换了，TR寄存器仍然不会变化。  
> 注意，我这里说的的是绝大多数情况，而没有说死。虽然操作系统不依靠TSS来实现多任务切换，但这并不意味着CPU提供的TSS操作系统一点也没有使用。还是存在一些特殊情况，如一些异常处理会使用到TSS来执行处理。

![](https://pic4.zhimg.com/v2-a60996d09b143034425959ce34ae29db_b.jpg)

控制寄存器、描述符寄存器、任务寄存器关系

### 模型特定寄存器

- **_IA32\_SYSENTER\_CS_**
- **_IA32\_SYSENTER\_ESP_**
- **_IA32\_SYSENTER\_EIP_**

这三个**MSR**寄存器是用来实现**快速系统调用**。

在早期的x86架构CPU上，系统调用依赖于软中断实现，类似于前面调试用到的int 3指令，在Windows上，系统调用用到的是**int 2e**，在Linux上，用的是**int 80**。

软中断毕竟还是比较慢的，因为执行软中断就需要[内存查表](https://www.zhihu.com/search?q=%E5%86%85%E5%AD%98%E6%9F%A5%E8%A1%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22502718676%22%7D)，通过IDTR定位到IDT，再取出函数进行执行。

系统调用是一个频繁触发的动作，如此这般势必对性能有所影响。在进入奔腾时代后，就加上了上面的三个MSR寄存器，**分别存储了执行系统调用后，内核系统调用入口函数所需要的段寄存器、堆栈栈顶、函数地址，不再需要内存查表**。快速系统调用还提供了专门的CPU指令**sysenter/sysexit**用来发起系统调用和退出系统调用。

在64位上，这一对指令升级为**syscall/sysret**。

## x86\_64架构(64bit)

### 通用寄存器

- **_rax：通常用于存储函数调用返回值_**
- **_rsp：_栈顶指针，指向栈的顶部**
- **_rdi：第一个入参_**
- **_rsi：第二个入参_**
- **_rdx：第三个入参_**
- **_rcx：第四个入参_**
- **_r8：第五个入参_**
- **_r9：第六个入参_**
- **_rbx：_**数据存储，遵循**_Callee Save_**原则
- **_rbp：_**数据存储，遵循**_Callee Save_**原则
- **_r12~r15：_**数据存储，遵循**_Callee Save_**原则
- **_r10~r11：_**数据存储，遵循**_Caller Save_**原则

> _Callee Save：函数调用时，父函数无需保存这些寄存器值，可以直接调用子函数，子函数使用这些寄存器之前，需要保存这些寄存器值，_即这些寄存器的值是由被调用者来保存和恢复。  
> _Caller Save：函数调用时，父函数需要压栈保存这些寄存器值，I子函数可随意使用这些寄存器。_

### 标志寄存器

**_eflags_** 寄存器升级为64bit的 **_rflags_**，不过其高32位并没有新增什么功能，保留为将来使用。

### 指令寄存器

**_eip_**寄存器升级为64位的**_rip_**寄存器。

### 控制寄存器

除了将 **_cr0~cr4_** 寄存器位宽增加为64bit外，还增加了64bit位宽的 **_cr8_** 寄存器，用于获取当前IRQL权限等级

### 模型特定寄存器

> 参考x86架构下的MSR寄存器