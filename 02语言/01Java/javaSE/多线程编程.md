### Thread类

- 自定义线程类继承**Thread**类
- 重写**run()** 方法
- 创建线程对象，调用**start()** 方法启用线程

**示例**
```java
public class ThreadTest {  
    public static void main(String[] args) {  
        Thread thread1 = new MyThread(1);  
        Thread thread2 = new MyThread(2);  
  
        thread1.start();  
        thread2.start();  
  
        System.out.println("main线程已退出");  
  
    }  
}  
  
  
class MyThread extends Thread{  
   private int num;  
   private int i;  
  
   MyThread() {  
       this(1);  
   }  
   MyThread(int num) {  
       this.num = num;  
       this.i = 0;  
   }  
     
    @Override  
    public void run() {  
       while (true) {  
           System.out.println("线程" + this.num + "第" + this.i++ + "次运行");  
           try {  
               sleep(1000);  
           } catch (InterruptedException e) {  
               throw new RuntimeException(e);  
           }  
  
       }  
  
    }  
}
```


### 实现Runnable接口

> [!info]  推荐使用/**Runnable**对象，因为Java只能单继承

**基础步骤**
- 定义MyRunnable类实现**Runnable**接口
- 实现**run()** 方法，编写线程执行体
- 创建MyRunnable实列线程对象
- 创建代理的**Thread** 类
- 调用**start()** 方法启动线程

**示例**
```java
public class RunnableTest {  
    public static void main(String[] args) {  
        MyThreadByRunnable myThreadByRunnable1 = new MyThreadByRunnable(1);  
        MyThreadByRunnable myThreadByRunnable2 = new MyThreadByRunnable(2);  
        Thread myThread1 = new Thread(myThreadByRunnable1);  
        Thread myThread2 = new Thread(myThreadByRunnable2);  
  
        myThread1.start();  
        myThread2.start();  
  
        System.out.println("main线程休眠中");  
  
    }  
}  
  
class MyThreadByRunnable implements Runnable {  
    private int num;  
    private int i;  
  
    MyThreadByRunnable() {  
        this(1);  
    }  
    MyThreadByRunnable(int num) {  
        this.num = num;  
        this.i = 0;  
    }  
  
    @Override  
    public void run() {  
        while (true) {  
            System.out.println("线程" + this.num + "第" + this.i++ + "次运行");  
            try {  
                sleep(1000);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
  
        }  
    }  
  
}
```


### Thread与Runnable

- 继承Thread类
	- 子类继承Thread类具备多线程能力
	- 启动线程：子类对象. start()
	- **不建议使用：避免OOP单继承局限性**
- 实现Runnable接口
	- 实现接口Runnable具有多线程能力
	- 启动线程：传入目标对象+Thread对象.start()
	- **推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用**


### 线程方法

|  方法                              |  说明                                                                                                                                                                 |
|:---------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  setPriority(int newPriority)    |  更改线程的优先级                                                                                                                                                           |
|  static void sleep(long millis)  |  <div>在指定的毫秒数内让当前正在执行的线程休<span style="background-color: var(--background-primary); color: var(--text-normal); font-family: var(--font-interface);">眠</span></div>   |
|  void join()                     | 等待该线程终止                                                                                                                                                             |
|  static void yield()             |  <div>暂停当前正在执行的线程对象，并执行其他<span style="background-color: var(--background-primary); color: var(--text-normal); font-family: var(--font-interface);">线程</span></div>  |
|  boolean isAlive()               | 测试线程是否处于活动状态                                                                                                                                                        |  

- **停止线程**
	- 不推荐使用JDK提供的 stop()
	- destroy()方法【已废弃】
	- 推荐线程自己停止下来
	- 建议使用一个标志位进行终止变量
	- 当flag=false，则终止线程运行
	- ![](http://imgs.kbpoyo.top/imgs/javaSE_202207052307426.png)
- **线程休眠**
	- sleep (时间) 指定当前线程阻塞的毫秒数
	- sleep存在异常InterruptedException
	- sleep时间达到后线程进入就绪状态
	- sleep可以模拟网络延时，倒计时等
	- 每一个对象都有一个锁，sleep不会释放锁
- **线程礼让**
	- 礼让线程，让当前正在执行的线程暂停，但不阻塞
	- 将线程从运行状态转为就绪状态
	- 让cpu重新调度，礼让不一定成功！看CPU心情
- **Join**
	- Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞
	- 可以想象成插队
	- ![](http://imgs.kbpoyo.top/imgs/javaSE_202207052311780.png)
- **线程状态观测**
	- Thread.State
		- *NEW*：尚未启动的线程处于此状态
		- *RUNNABLE* ：在Java虚拟机中执行的线程处于此状态
		- *BLOCKED*：被阻塞等待监视器锁定的线程处于此状态
		- *WAITING*：正在等待另一个线程执行特定动作的线程出此状态
		- *TIMED_WAITING*：正在等待另一个线程执行特定动作并达到指定等待时间的线程处于此状态
		- *TERMINATED*：已退出的线程状态处于此状态
- **线程优先级**
	- 线程的优先级用数字表示，范围从1~10
		- *Thread.MIN_PRIORITY* = 1
		- *Thread.MAX_PRIORITY* = 10
		- *Thread.NORM_PRIORITY* = 5
	- 使用以下方式改变或获取优先级
		- *getPriority()* 
		- *setPriority(int xxx)*
- **守护线程**
	- 线程分为用户线程和守护线程
	- 虚拟机必须确保用户线程执行完毕
	- 虚拟机不用等待守护线程执行完毕
	- 如,后台记录操作日志,监控内存,垃圾回收等


### 线程同步

>由于同一进程的多个线程共享同一块存储空间 , 在带来方便的同时,也带来了访问
冲突问题 , 为了保证数据在方法中被访问时的正确性 , 在访问时加入 锁机制
**synchronized** , 当一个线程获得对象的排它锁 , 独占资源 , 其他线程必须等待 ,
使用后释放锁即可 . 
**存在以下问题 :**
> - 一个线程持有锁会导致其他所有需要此锁的线程挂起 
> - 在多线程竞争下 , 加锁 , 释放锁会导致比较多的上下文切换 和 调度延时,引起性能问题 
> - 如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒置 , 引起性能问题 .


- **synchronized**
	-  同步方法 : public *synchronized* void method(int args) {}
		- synchronized方法控制对 “对象” 的访问 , 每个对象对应一把锁
		- 每个synchronized方法都必须获得调用该方法的对象的锁才能执行, 否则线程会阻塞
		- 方法一旦执行 , 就独占该锁 , 直到该方法返回才释放锁
		- 后面被阻塞的线程才能获得这个锁 , 继续执行
		- *缺陷* : 若将一个大的方法申明为synchronized 将会影响效率
	- 同步块 : synchronized (*Obj* ) { }
		- *Obj* 称之为 同步监视器
		- *Obj* 可以是任何对象 , 但是推荐使用共享资源作为同步监视器
		- 同步方法中无需指定同步监视器 , 因为同步方法的同步监视器就是*this* , 就是这个对象本身 , 或者是 class
		- 同步监视器的执行过程
			1. 第一个线程访问 , 锁定同步监视器 , 执行其中代码 .
			2. 第二个线程访问 , 发现同步监视器被锁定 , 无法访问 .
			3. 第一个线程访问完毕 , 解锁同步监视器 .
			4. 第二个线程访问, 发现同步监视器没有锁 , 然后锁定并访问
- **Lock(锁)**
	- ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。
	- ![](http://imgs.kbpoyo.top/imgs/javaSE_202207052344752.png)

**synchronized 与 Lock 的对比**
- Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放
- Lock只有代码块锁，synchronized有代码块锁和方法锁
- 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）
- 优先使用顺序：
	- Lock > 同步代码块（已经进入了方法体，分配了相应资源）> 同步方法（在方
法体之外）

> [!info] **死锁**
>  多个线程各自占有一些共享资源 , 并且互相等待其他线程占有的资源才能运行 , 而
导致两个或者多个线程都在等待对方释放资源 , 都停止执行的情形 . 某一个同步块
同时拥有 “ 两个以上对象的锁 ” 时 , 就可能会发生 “ 死锁 ” 的问题 .

> [!info] 死锁避免方法
> 产生死锁的四个必要条件：
> 1. *互斥条件*：一个资源每次只能被一个进程使用
> 2. *请求与保持条件*：一个进程因请求资源而阻塞时，对已获得的资源保持不放
> 3. *不剥夺条件* : 进程已获得的资源，在末使用完之前，不能强行剥夺。
> 4. *循环等待条件* : 若干进程之间形成一种头尾相接的循环等待资源关系
> 
> 上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件
就可以避免死锁发生



### 线程通信

**生产者与消费者模型**

>在生产者消费者问题中 , 仅有synchronized是不够的
synchronized 可阻止并发更新同一个共享资源 , 实现了同步
synchronized 不能用来实现不同线程之间的消息传递 (通信)


**解决方法**

| 方法(Object类中)       | 作用                                                                                                                                                                                 |
|:-------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| wait()             | <div>表示线程一直等待 , 直到其他线程通知 , 与sleep不同 ,<span style="background-color: var(--background-primary); color: var(--text-normal); font-family: var(--font-interface);">会释放锁</span></div>   |
| wait(long timeout) | 指定等待的毫秒数                                                                                                                                                                           |
| notify()           | 唤醒一个处于等待状态的线程                                                                                                                                                                      |
| notifyAll()        | <div>唤醒同一个对象上所有调用wait()方法的线程 , 优先级<span style="background-color: var(--background-primary); color: var(--text-normal); font-family: var(--font-interface);">别高的线程优先调度</span></div> |  

> [!warning]  注意
> 均是Object类的方法 , 都只能在同步方法或者同步代码块中
> 使用,否则会抛出异常**IllegalMonitorStateException**

